The Logging Flow
Micrometer → SLF4J → Logback
Here's how it works step by step:
1. Micrometer's Logging Calls
Micrometer's internal code uses SLF4J's logging API. For example:
java
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

private static final Logger logger = LoggerFactory.getLogger(SomeClass.class);
logger.debug("Meter registered: {}", meterId);
Micrometer doesn't depend on any specific logging implementation - it only depends on the SLF4J API (the slf4j-api artifact).
2. SLF4J's Binding Mechanism
At runtime, SLF4J uses a static binding mechanism to find the logging implementation:

When LoggerFactory.getLogger() is called, SLF4J looks for a binding on the classpath
It searches for a class implementing org.slf4j.spi.SLF4JServiceProvider (SLF4J 2.x) or org.slf4j.impl.StaticLoggerBinder (SLF4J 1.x)
The binding acts as a bridge between SLF4J's API and the actual logging framework

3. Logback as the SLF4J Implementation
When you include Logback in your dependencies, you get:

logback-classic: This artifact contains the SLF4J binding for Logback
logback-core: The actual logging implementation

The logback-classic module includes the binding class that SLF4J discovers at runtime, connecting SLF4J's Logger interface to Logback's internal Logger implementation.
4. The Actual Log Processing
Once the binding is established:

Micrometer calls logger.debug("message")
SLF4J's Logger interface forwards this to the bound implementation
Logback's Logger receives the call
Logback applies its configuration (log levels, appenders, patterns, filters)
The log message is formatted and written to the configured destinations (console, files, etc.)

5. Configuration
Logback is configured through logback.xml or logback-spring.xml, where you can:

Set log levels for Micrometer's packages (e.g., io.micrometer)
Configure appenders and output formats
Filter what gets logged

Example configuration:
xml<logger name="io.micrometer" level="DEBUG"/>
Key Points

Compile-time dependency: Micrometer only needs slf4j-api
Runtime binding: SLF4J automatically discovers Logback via the service provider mechanism
No direct coupling: Micrometer never directly calls Logback code
Swappable implementation: You could replace Logback with Log4j2 or java.util.logging by changing the binding dependency

This design provides complete decoupling between Micrometer and the actual logging implementation, giving you flexibility to choose your logging framework.
